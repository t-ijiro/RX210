//	Copyright 2010 PaletteSoft LLC

// ***************************************************************************
// *	動作仕様															 *
// ***************************************************************************
/*
	ＰＷＭ制御サンプル　その１	PIC12F683	CLOCK:INTRCIO/4MHz

	GP0:LED0	Out	0:消灯、1:点灯
	GP1:LED1	Out	0:消灯、1:点灯
	GP2:LED2	Out	0:消灯、1:点灯
	GP3:MCLR	-----
	GP4:SW1		In	0:オン、1:オフ	内蔵プルアップ利用のこと
	GP5:SW0		In	0:オン、1:オフ	内蔵プルアップ利用のこと

	起動直後は５秒間ＬＥＤを点灯。続いてＰＷＭ制御に移行する。

	制御周期　：LED0:100ms, LED1:50ms, LED2:10ms　…　固定周期
	デューティ：総て５０％

	割り込みは使用せずタイマ０のタイムアウトをポーリングする。
	タイマ０のタイムアウト周期は約１ｍｓ（計算上は１０２４ｕｓ）
*/

// ***************************************************************************
// *	インクルードファイル												 *
// ***************************************************************************

#include	<pic.h>														//	プロジェクト設定で選択されたデバイスが自動的に引用されます

#include	<string.h>													//	文字列操作系

#include	"_AtrDef.h"													//	定数、データ型の宣言

// ***************************************************************************
// *	プログラムバージョン												 *
// ***************************************************************************

#define	VER1					0										//	上位十の位	数字１桁で指定（英字禁止）
#define	VER2					1										//	上位一の位	数字１桁で指定（英字禁止）
//								.
#define	VER3					0										//	下位十の位	数字１桁で指定（英字禁止）
#define	VER4					1										//	下位一の位	数字１桁で指定（英字禁止）	★　将来の不具合対応

#define	COPYRIGHT				"Copyright 2010 PaletteSoft LLC"		//	著作権文字列

// ***************************************************************************
// *	動作環境															 *
// ***************************************************************************

	//	***** 動作環境 *****

__CONFIG(	FCMDIS														//	フェールセーフクロックモニタ動作禁止
		&	IESODIS														//	内外クロックのスイッチオーバーモード動作禁止
		&	BORDIS														//	ブラウンアウト検出禁止
		&	UNPROTECT													//	データメモリ（EEPROM）のプロテクト禁止
		&	UNPROTECT													//	プログラムメモリのプロテクト禁止
		&	MCLREN														//	GP3/_MCLR端子は_MCLRで利用（自動的にプルアップされる）
		&	PWRTEN														//	パワーアップタイマ動作許可
		&	WDTDIS														//	ウォッチドッグタイマ動作禁止
		&	INTIO														//	内部クロック利用してRA4、RA5端子は入出力で利用
);

	//	***** ＩＤ情報 *****

__IDLOC7(VER1, VER2, VER3, VER4);										//	バージョン番号として定義（情報の意味付けは任意）

	//	***** 源発振 *****

#define	_XTAL_FREQ				4000000									//	動作周波数（Ｈｚ）		…　__delay_XXで引用される

// ***************************************************************************
// *	データ型															 *
// ***************************************************************************

typedef struct {														//	ソフトウェアによるＰＷＭ制御情報
	UB		Count;														//	作業用カウンタ
	UB		State;														//	状態（０：オフ中、１：オン中）
	UB		MasterOn;													//	マスタカウンタ：オン用
	UB		MasterOff;													//	マスタカウンタ：オフ用
} sLedPwm;

// ***************************************************************************
// *	固定値																 *
// ***************************************************************************

	//	***** ＬＥＤ自己診断 *****

#define	LED_DIAG_TIME			5000									//	診断用点灯時間（ｍｓ）

	//	***** ＬＥＤ *****

enum {
	LED0,																//	０：ＬＥＤ０
	LED1,																//	１：ＬＥＤ１
	LED2,																//	２：ＬＥＤ２
	LED_TOTAL															//	３：ＬＥＤ総数
};

#define	MASK_LED				0b00000111								//	ＬＥＤデータのマスク

// ***************************************************************************
// *	グローバル変数														 *
// ***************************************************************************

union {
	UB	BYTE;															//	バイトアクセス用
	struct {
		UINT	Led0	: 1;											//	ＬＥＤ０
		UINT	Led1	: 1;											//	ＬＥＤ１
		UINT	Led2	: 1;											//	ＬＥＤ２
		UINT	Dummy	: 5;											//	ダミー
	} BIT;
} vLedData;																//	ＬＥＤ編集データ

sLedPwm	vLedPwm[LED_TOTAL];												//	ソフトウェアによるＰＷＭ制御

UB	vPortData;															//	出力ポートのバックアップ

// ***************************************************************************
// *	テーブル															 *
// ***************************************************************************

const	sLedPwm		tLedPwm[LED_TOTAL] = {								//	ＰＷＭ制御情報の初期データ（処理の都合でカウンタの初期値は１、オフ状態）
//		Count	State	MasterOn	MasterOff
	{	1,		0,		50,			50	},								//	ＬＥＤ０	50ms点灯、50ms消灯、デューティ５０％
	{	1,		0,		25,			25	},								//	ＬＥＤ１	25ms点灯、25ms消灯、デューティ５０％
	{	1,		0,		 5,			 5	}								//	ＬＥＤ２	 5ms点灯、 5ms消灯、デューティ５０％
};

// ***************************************************************************
// *	マクロ宣言															 *
// ***************************************************************************

	//	***** ＬＥＤ制御 *****

#define	mLed0_On()				vLedData.BIT.Led0 = 1					//	ＬＥＤ０点灯
#define	mLed1_On()				vLedData.BIT.Led1 = 1					//	ＬＥＤ１点灯
#define	mLed2_On()				vLedData.BIT.Led2 = 1					//	ＬＥＤ２点灯

#define	mLed0_Off()				vLedData.BIT.Led0 = 0					//	ＬＥＤ０消灯
#define	mLed1_Off()				vLedData.BIT.Led1 = 0					//	ＬＥＤ１消灯
#define	mLed2_Off()				vLedData.BIT.Led2 = 0					//	ＬＥＤ２消灯

// ***************************************************************************
// *	プロトタイプ宣言													 *
// ***************************************************************************

	//	***** マネジメント *****

void	main(void);
void	LedPwmUpdate(sLedPwm *Info);
void	LedDiag(UH Count);

	//	***** デバイス制御 *****

void	DevInit(void);

	//	***** タイマ制御 *****

void	TmInit(void);
void	TmWait(void);

// ***************************************************************************
// *	処理本体															 *
// ***************************************************************************

//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
//
// 		マネジメント
//
//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
void	Mng______(void) {}												//	見出し用関数

//============================================================================
//	メイン
//----------------------------------------------------------------------------
//	入力：	無し
//	出力：	無し
//----------------------------------------------------------------------------
//	備考：	スタートアップリーチンからのジャンプ命令で呼び出されます。
//			本関数は無限ループであり、脱出することはありません。
//============================================================================
void	main(void)
{
	//	***** はじめに *****

	di();																//	総ての割り込み禁止を明示

	DevInit();															//	デバイス初期設定
	TmInit();															//	タイマ初期設定				…　以後は１ｍｓ周期でタイムアウトを発生

	vLedData.BYTE =	0b00000000;											//	ＬＥＤ全消灯状態

	LedDiag(LED_DIAG_TIME);												//	ＬＥＤの全点灯診断			…　この中で点灯待機、終了後は全消灯

	memcpy(vLedPwm, tLedPwm, sizeof(vLedPwm));							//	ＰＷＭ制御情報を初期設定	…　初期化済みデータから引用

	//	***** 無限巡回 *****

	while (1) {															//	無限ループです

		//	***** 制御周期生成とＬＥＤ表示更新 *****

		TmWait();														//	タイマのタイムアウト待機	…　この関数直下は常に制御周期の先頭になる

		GPIO = (vPortData & MASK_LED) | vLedData.BYTE;					//	ＬＥＤ編集データを一括更新	…　制御周期で毎回更新

		//	***** ＰＷＭ制御 *****

		LedPwmUpdate(&vLedPwm[LED0]);									//	ＬＥＤ０のＰＷＭ制御情報を更新
		if (vLedPwm[LED0].State)	mLed0_On();							//	ステートによりＬＥＤ制御
		else						mLed0_Off();						//	＝０：消灯、≠０：点灯

		LedPwmUpdate(&vLedPwm[LED1]);									//	ＬＥＤ１のＰＷＭ制御情報を更新
		if (vLedPwm[LED1].State)	mLed1_On();							//	ステートによりＬＥＤ制御
		else						mLed1_Off();						//	＝０：消灯、≠０：点灯

		LedPwmUpdate(&vLedPwm[LED2]);									//	ＬＥＤ２のＰＷＭ制御情報を更新
		if (vLedPwm[LED2].State)	mLed2_On();							//	ステートによりＬＥＤ制御
		else						mLed2_Off();						//	＝０：消灯、≠０：点灯
	}
}

//============================================================================
//	ＰＷＭ制御情報の更新
//----------------------------------------------------------------------------
//	入力：	ＬＥＤのＰＷＭ制御情報格納アドレス
//	出力：	無し
//----------------------------------------------------------------------------
//	備考：	指定されるＬＥＤのＰＷＭ制御情報を更新します。
//============================================================================
void	LedPwmUpdate(sLedPwm *Info)
{
	Info->Count --;														//	カウント更新

	if (Info->Count == 0) {												//	カウント終了？
		if (Info->State == 0) {											//	現在オフ中？
			Info->State = 1;											//	今度はオン
			Info->Count = Info->MasterOn;								//	カウントの再設定
		}
		else {															//	現在オン中
			Info->State = 0;											//	今度はオフ
			Info->Count = Info->MasterOff;								//	カウントの再設定
		}
	}
}

//============================================================================
//	ＬＥＤの全点灯診断
//----------------------------------------------------------------------------
//	入力：	維持回数（１ｍｓ単位の回数）
//	出力：	無し
//----------------------------------------------------------------------------
//	備考：	総てのＬＥＤを点灯し、消灯します。
//============================================================================
void	LedDiag(UH Count)
{
	//	***** はじめに *****

	if (Count != 0) {													//	維持回数はある？

		//	***** ＬＥＤの点灯 *****

		mLed0_On();		mLed1_On();		mLed2_On();						//	ＬＥＤ全点灯
		GPIO = (vPortData & MASK_LED) | vLedData.BYTE;					//	出力ポートを一括編集

		//	***** 状態維持 *****

		while (Count--) {												//	維持回数が０になるまで巡回
			TmWait();													//	タイマのタイムアウト待機
		}

		//	***** ＬＥＤの消灯 *****

		mLed0_Off();	mLed1_Off();	mLed2_Off();					//	ＬＥＤ全消灯
		GPIO = (vPortData & MASK_LED) | vLedData.BYTE;					//	出力ポートを一括編集
	}
}

//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
//
// 		デバイス制御
//
//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
void	Dev______(void) {}												//	見出し用関数

//============================================================================
//	デバイス初期設定
//----------------------------------------------------------------------------
//	入力：	無し
//	出力：	無し
//----------------------------------------------------------------------------
//	備考：	デバイスの初期設定を行います。
//			リセット直後の初期値で済む場合は再設定していません。
//============================================================================
void	DevInit(void)
{
	//	***** 基本環境 *****

//						  76543210
	OPTION =			0b01111111;										//	オプションレジスタ
																		//	bit07:GPPU		0	入力ポートのプルアップ許可			★★★
																		//	bit06:INTEDG	1	外部割り込みは立ち上がりエッジ		未使用
																		//	bit05:T0CS		1	タイマ０は外部クロックを利用		未使用
																		//	bit04:T0SE		1	タイマ０の更新は立下りエッジ		未使用
																		//	bit03:PSA		1	プリスケーラはＷＤＴで利用			未使用
																		//	bit02:PS2		1	プリスケーラは１２８分周			未使用
																		//	bit01:PS1		1		（同上）
																		//	bit00:PS0		1		（同上）

	//	***** 入出力ポート *****										//	注意：たいていの場合、汎用入出力ポートは別機能が割りつけられている

//						  76543210
	vPortData		 =	0b00000000;										//	汎用入出力ポートデータの初期値
																		//	bit07:-----		0
																		//	bit06:-----		0
																		//	bit05:GP5		0	入力：ＳＷ０						入力なので無意味
																		//	bit04:GP4		0	入力：ＳＷ１						入力なので無意味
																		//	bit03:GP3		0	入力：ＭＣＬＲ						指定は無効
																		//	bit02:GP2		0	出力：ＬＥＤ２						消灯
																		//	bit01:GP1		0	出力：ＬＥＤ１						消灯
																		//	bit00:GP0		0	出力：ＬＥＤ０						消灯

	GPIO = vPortData;													//	出力ポートを一括編集	…　ビット操作によるRead&Modifyを行わない手法

//						  76543210
	CMCON0 =			0b00000111;										//	コンパレータ制御
																		//	bit07:-----		0
																		//	bit06:COUT		0	コンパレータ出力状態				読み出しのみ可
																		//	bit05:-----		0
																		//	bit04:CINV		0	出力反転しない						未使用
																		//	bit03:CIS		0	入力スイッチ設定					未使用
																		//	bit02:CM2		1	コンパレータオフ					★★★
																		//	bit01:CM1		1		（同上）						★★★
																		//	bit00:CM0		1		（同上）						★★★

//						  76543210
	ANSEL =				0b00000000;										//	アナログセレクタ
																		//	bit07:-----		0
																		//	bit06:ADCS2		0	ＡＤ変換クロック選択				未使用
																		//	bit05:ADCS1		0		（同上）
																		//	bit04:ADCS0		0		（同上）
																		//	bit03:ANS3		0	ＡＮ３未使用、ＧＰ４汎用入出力		★★★
																		//	bit02:ANS2		0	ＡＮ２未使用、ＧＰ２汎用入出力		★★★
																		//	bit01:ANS1		0	ＡＮ１未使用、ＧＰ１汎用入出力		★★★
																		//	bit00:ANS0		0	ＡＮ０未使用、ＧＰ０汎用入出力		★★★

//						  76543210
	TRISIO =			0b00111000;										//	汎用入出力ポート方向
																		//	bit07:-----		0
																		//	bit06:-----		0
																		//	bit05:GP5		1	入力：ＳＷ０						★★★
																		//	bit04:GP4		1	入力：ＳＷ１						★★★
																		//	bit03:GP3		1	入力：ＭＣＬＲ						読み出しのみ可
																		//	bit02:GP2		0	出力：ＬＥＤ２						★★★
																		//	bit01:GP1		0	出力：ＬＥＤ１						★★★
																		//	bit00:GP0		0	出力：ＬＥＤ０						★★★
}

//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
//
// 		タイマ制御
//
//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
//	◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆
void	Tm______(void) {}												//	見出し用関数

//============================================================================
//	初期設定
//----------------------------------------------------------------------------
//	入力：	無し
//	出力：	無し
//----------------------------------------------------------------------------
//	備考：	タイマ０の初期設定を行います。
//			タイムアウト周期は約１ｍｓ（１０２４μｓ）です。
//============================================================================
void	TmInit(void)
{
	//	***** タイマ０のモード設定 *****

	CLRWDT();															//	ＷＤＴのリフレッシュ	…　結果的に動作していないので効果無し
																		//								データシートに記載されている手法を踏襲
//						 76543210	   76543210
	OPTION = (OPTION & 0b11010000) | 0b00000001;						//	オプションレジスタ		…　設定済みの値を修正
																		//	bit07:GPPU		*	（変更なし）
																		//	bit06:INTEDG	*	（変更なし）
																		//	bit05:T0CS		0	タイマ０は内部クロックを利用		★★★
																		//	bit04:T0SE		*	（変更なし）
																		//	bit03:PSA		0	プリスケーラはタイマ０で利用		★★★
																		//	bit02:PS2		0	プリスケーラは４分周				★★★
																		//	bit01:PS1		0		（同上）
																		//	bit00:PS0		1		（同上）

	//	***** タイマ０のタイムアウト状況を解除 *****

	TMR0 = 0;															//	タイマ０カウンタのクリア（プリスケーラも同時にクリア）
	T0IE = 0;															//	タイマ０割込は禁止
	T0IF = 0;															//	タイマ０割込要求を解除	…　ＴＭＲ０レジスタのオーバーフローを示す
}

//============================================================================
//	タイムアウト待機
//----------------------------------------------------------------------------
//	入力：	無し
//	出力：	無し
//----------------------------------------------------------------------------
//	備考：	タイマ０のタイムアウト（１０２４μｓ）を待機します。
//			前回の関数実行直後から、今回の関数実行直後の間隔は一定です。
//============================================================================
void	TmWait(void)
{
	while (T0IF == 0)	;												//	タイマ０割り込み要求が発生するまで待機
	T0IF = 0;															//	タイマ０割込要求解除
}

// ***************************************************************************
// ***************************************************************************
// *																		 *
// ***************************************************************************
// ***************************************************************************

//	Copyright 2010 PaletteSoft LLC

